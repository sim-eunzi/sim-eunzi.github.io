---
title: 스코프란 무엇인가?
date: '2021-05-13T20:30:37.121Z'
description: '변수가 살아있는 곳을 알아보자'
---

프로그래밍을 하다보면 변수는 어디에 살아있는지, 프로그램이 필요한 변수는 어떻게 찾는지 의문이 든다.  
특정 장소에 변수를 저장하고 나중에 변수를 찾는 데 잘 정의된 규칙이 필요한데, 이런 규칙을 **스코프**라고 한다.

`var a = 2` 의 구문을 보고 실제 엔진과 컴파일러, 스코프가 프로그램을 이해하는 방법을 살펴보자.

---

1. 컴파일러는 렉싱을 통해 위 구문을 토큰으로 쪼개서 **트리구조(AST)** 로 만든다.
2. `var a` 를 만나면 스코프에게 변수 a 가 특정한 스코프 컬렉션 안에 있는지 묻는다.
3. 변수 a 가 존재하면, 컴파일러는 선언을 무시하고, 존재하지 않으면 스코프 컬렉션 내에 선언하라고 요청한다.
4. 컴파일러는 `a = 2` 대입문의 처리를 위해 엔진이 실행할 수 있는 코드를 만든다.
5. 엔진이 실행하는 코드는 스코프에게 변수 a 가 스코프 컬렉션 내에서 접근할 수 있는지 확인한다. 가능하다면 변수 a 를 사용하고, 없다면 엔진은 다른 스코프를 찾아본다.

### 우선, 컴파일러에 대해 알아보자

위 단계에서 엔진이 코드를 실행할 때, 변수 a 가 선언된 적이 있는지 스코프에서 검색한다.

이때 엔진이 어떤 종류의 검색을 하냐에 따라서 검색결과가 달라지는데,,   
위 경우에서는 변수 a 를 찾기위해 `LHS 검색`을 한다.

다른 종류의 검색은 `RHS 검색` 이다.

```jsx
function foo(a) {
  // LHS 검색 "a=2 연산을 진행하면서 a에 값을 대입하는 연산"
  console.log(a) // RHS 검색 "a를 사용하기 위해 RHS"
}
foo(2) // RHS 검색 "foo의 리턴값을 찾아서 가져와라"
```

LHS 검색은 변수가 대입연산자 왼쪽에 있을 때 수행하고, (대입할 대상) `a = 2`  
RHS 검색은 변수가 대입연산자 오른쪽에 있을 때 수행한다. (대입할 값) `console.log(a)`

LHS과 RHS를 구분하는 것이 왜 중요할까? 이는 변수가 선언되지 않았을 때 서로 다르게 동작하기 때문이다.

```jsx
function foo(a) {
  console.log(a + b)
  b = a
}

foo(2)
```

b에 대한 RHS 검색이 실패하면, '선언되지 않은 변수'라 하고 중첩 스코프 안 어디서도 찾지못하면 `ReferenceError` 를 발생

반면에 LHS 검색을 수행하여 변수를 찾지못하고 글로벌 스코프에 도달하면, (strict mode 가 아닐 경우) 글로벌 스코프는 엔진이 찾고있는 **새로운 변수를 생성**해서 넘겨준다.

### 중첩 스코프

하나의 블록이나 함수는 다른 블록이나 함수 안에 중첩될 수 있으므로 스코프도 중첩이 될 수 있다.

따라서 대상 변수를 현재 스코프에서 발견하지 못하면, 엔진은 다음 바깥의 스코프로 넘어가   
가장 바깥 스코프인 **글로벌 스코프**에 도달할 때까지 계속한다.

```jsx
function foo(a) {
  console.log(a + b)
}
let b = 2
foo(2)
```

foo함수 안에서 b 에 대한 RHS 참조를 찾을 수 없어, 엔진은 foo의 바깥 스코프(글로벌 스코프)에서 찾게된다.  
중첩 스코프를 탐색할 때 사용하는 간단한 규칙은 아래와 같다.

- 엔진은 현재 스코프에서 변수를 찾기 시작하고, 찾지 못하면 한 단계씩 올라간다.
- 최상위 글로벌 스코프에 도달하면 찾든 못찾든 검색을 멈춘다.

### 정리하기

스코프는 어디서 어떻게 변수를 찾는가를 결정하는 규칙의 집합이다.   

변수를 검색하는 이유는 변수에 값을 대입(LHS)하거나, 변수의 값을 얻어오기 위해서(RHS)이다.

LHS 와 RHS 참조 검색은 현재 실행 중인 스코프에서 시작하고,   
대상 변수를 찾지 못했을 경우 한 번에 한 스코프씩 상위 스코프로 넘어가여 대상 변수를 찾는다.

위 작업은 글로벌 스코프에 이를 때까지 계속하고, 이 때는 대상을 찾든 못찾는 작업을 중지한다.

RHS 참조가 대상을 찾지못하면 `ReferenceError` 가 발생하고, LHS 참조가 대상을 찾지못하면 새로운 변수가 생성된다.
