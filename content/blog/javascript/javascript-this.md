---
title: 자바스크립트 this 에 대한 모든 것.
date: '2021-05-27T20:31:37.121Z'
description: '알면 알수록 헷갈리는 this에 대해 알아보자'
---

자바스크립트로 코딩을 작성하면서 `this` 를 사용하면서 내 의도대로 동작이 되지않아 에러를 잡기 힘들었던 상황이 있다.  막연히 `this` 는 자기자신을 뜻하는 거지 않겠어? 라고 생각하면서 사용했는데 동작 원리에 대해 조금만 생각하면 핵심을 제대로 파악할 수 있다. 

이 헷갈리고 복잡한 `this` 에 대해 완전히 이해를 하고 정리해보자.

### 우리가 this 에 대해 오해하고 있던 것

나는 자바스크립트에서 this 를 사용했을 때, 객체지향 언어에서의 기억이 먼저 떠올랐다.  
객체지향에서의 this 는 클래스로 생성한 인스턴스 객체 그 자체를 의미하는데,   
클래스에서만 사용을 하는거라 혼란의 여지가 없었다.

우리는 보통 자바스크립트에서의 this 를 **(1) 자기 자신의 함수, 그 자체**를 의미하거나,   
**(2) 함수 자신의 스코프**를 가르킨다고 착각을 한다.

둘 다 어떤 면에선 맞지만 this 는 어떤 식으로도 함수의 렉시컬 스코프를 참조하지 않는다!  
this 는 작성 시점이 아닌 **런타임 시점에 바인딩 되어 함수가 호출 될 때 만들어지는 콘텍스트에 따라 결정**되기 때문!

좀 더 자세히 말하자면 어떤 함수를 호출하면 만들어지는 실행 컨텍스트에는 콜스택과 호출방법, 전달된 인자 등의 정보가 담겨져 있는데, this 레퍼런스는 그 중 하나로 함수가 실행되는 동안 이용할 수 있다.

그래서 **함수를 어떤 방식으로 호출했냐**(호출부)에 따라 this의 값이 달라지는데, 그 다양한 상황에 대해서 알아보자!

## 호출부에 따라 달라지는 this 의 규칙

this 바인딩을 이해하기 위해선 우리는 함수가 호출된 코드를 확인하고,  
**this가 가르키는 것**이 무엇인지를 찾아야한다.

호출 스택에서 현재 실행 중인 함수 직전의 호출코드 내부에 있으니 코드를 주의깊게 잘 살펴보자.  
호출부를 알았으면, 아래에 적힌 4가지 규칙 중 어느 것이 해당되는지 확인하고 우선순위를 따져보면 된다.

### (1) 기본 바인딩 (단독 함수 호출)

가장 평범한 함수 호출이자, 나머지 규칙에 해당하지 않을 경우 적용되는 this 의 기본 규칙이다.

```jsx
function foo() {
  console.log(this.a)
}
var a = 2
foo() // 2
```

위 코드는 호출한 주체가 없이 전역 컨텍스트에서 실행되었기 때문에, `var a = 2` 와 같이 전역 변수를 선언하면 엔진은 이를 전역객체의 프로퍼티로 할당한다. 그래서 `foo()` 함수 호출 시 `this.a` 는 **전역 객체 a** 이기 때문에, 기본 바인딩이 적용되어 `this` 역시 전역 객체를 참고하게 된다.

### (2) 암시적 바인딩

호출부에 **콘텍스트 객체**가 있는지, **객체의 소유/포함 여부를 확인하는 방법**이다.

```jsx
function foo() {
  console.log(this.a)
}
var obj = {
  a: 2,
  foo: foo,
}
obj.foo() // 2
```

위 코드에서는 obj 객체가 foo() 함수를 프로퍼티로 참조하고 있다. foo() 를 처음부터 소유/포함 한 것은 아니지만, 함수 호출 시점에서는 obj 콘텍스트로 foo() 를 참조하므로 함수의 레퍼런스를 소유/포함 한다고 말할 수 있다. 이 경우 **콘텍스트 객체가 함수 호출 시 this 에 바인딩**이 된다.

다른 방식으로 기억하기 쉽게 생각하자면, `obj.foo()` 와 같이 **자신을 호출한 대상 객체(obj) 에 관한 동작을 수행하는 것**을 **메서드**라고 하며, **메서드가 호출된 경우는 메서드 내부에서의 this 는 호출한 객체에 대한 정보**가 바인딩이 된다.

**콜백 함수를 호출 했을 때, 함수 내부에서의 this** 는 좀 더 애매하게 실행이 된다.

**제어권을 넘겨 받은 함수에서 콜백 함수에 별도로 this 의 대상을 정한 경우는 그 대상을 참고**하게 되고,

정하지 않은 경우는 전역 객체를 참조하게 된다.

```jsx
setTimeout(function () {
  console.log(this)
}) // (1) window 전역객체
  [(1, 2, 3, 4, 5)].forEach(function (x) {
    // (2) window 전역객체, 1,2,3,4,5
    console.log(this, x)
  })

document.body.querySelector('#btn').addEventListener('click', function (e) {
  console.log(this, e) // (3) '#btn' 에 관한 엘리먼트 객체
})
```

- 번외로,, **메서드 내부에서 this 를 우회하는 방법**은?

  호출부가 없을 경우, 가끔 상위 스코프의 this 를 저장해서 쓰고 싶을 때 우회해서 사용하는 두가지 방법을 알아보자

  - 변수를 활용

    `_this` , `self` 등과 같은 변수 명으로 상위 스코프에 this 를 저장해서 사용하는 방법이다.

    ```jsx
    var obj = {
      outer: function () {
        var self = this
        console.log(this) // (1) obj { outer: ,, }
        var innerFunc = function () {
          // 여기서 상위 스코프(outer)의 this를 참조해서 쓰려고 한다.
          console.log(self) // (2) obj { outer: ,, }
        }
        innerFunc()
      },
    }
    obj.outer()
    ```

  - **화살표 함수 (arrow function) 사용**

    ES6 에서 함수 내부에서 this 가 전역객체를 바라보는 문제를 보안하고자, **this 를 바인딩 하지 않는 화살표 함수**를 도입했다. 화살표 함수는 **실행 컨텍스트를 생성할 때 this 바인딩 과정 자체가 빠지게 되어, 상위 스코프의 this 를 그대로** 활용할 수 있다.

    ```jsx
    var obj = {
      outer: function () {
        console.log(this) // (1) obj { outer: ,, }
        var innerFunc = () => {
          console.log(this) // (2) obj { outer: ,, }
        }
        innerFunc()
      },
    }
    obj, outer()
    ```

### (3) 명시적 바인딩

암시적 바인딩에서는 함수 레퍼런스를 객체에 넣기 위해 객체 자신을 변형하고, 함수 레퍼런스 프로퍼티를 통해 this를 간접적으로 바인딩 했다.

세번째 규칙은 객체에 함수 프로퍼티를 더하지 않고, **this 에 별도로 대상 객체를 바인딩하는 방법**이다.

자바스크립트의 유틸리티인 `call() 과 apply()` 메서드가 바로 이런 방법이다.

두 메서드는 **this 에 바인딩할 객체를 첫째 인자로 받아 이 객체를 this로 세팅**한다.

```jsx
function foo() {
  console.log()
}
```

작성중 ..
