---
title: 변수의 유효범위와 클로저
date: '2021-05-27T20:31:37.121Z'
description: '자바스크립트는 함수 지향 언어입니다. 클로저는 함수형 프로그래밍에서 등장하는 보편적인 특징입니다... '
---

자바스크립트는 함수 지향 언어입니다.  
클로저는 함수형 프로그래밍에서 등장하는 보편적인 특징입니다.  
자바스크립트에선 함수가 생성된 이후에 외부 변수가 변경되면 함수는 새로운 값을 가져올까요?  
변수의 유효범위와 클로저의 개념을 이해하면 위와같은 시나리오를 제대로 알 수 있습니다.

### 렉시컬 환경 (Lexical Environment)

**(1) 변수**

자바스크립트에서 실행중인 함수, 코드 블록은 렉시컬 환경을 가진다.  

  **환경 레코드 (Environment Record)** : 모든 지역변수를 프로퍼티로 저장하는 객체  
  **외부 렉시컬 환경 (Outer Lexical Environment) :** 외부 코드와 연관

변수는 특수 내부 객체인 환경 레코드의 프로퍼티로, 이를 변경하면 헤당 환경 레코드에서 변경된다.  
스크립트 전체와 관련된 렉시컬 환경을 **전역(Global) 렉시컬 환경**이라 한다.

**(2) 함수**

함수 선언문으로 선언한 함수는 일반 변수와 달리, 렉시컬 환경이 만들어지는 동시 바로 사용할 수 있다.   
변수는 선언이 될 때까지 사용할 수 없다.

  ```jsx
  let phrase = 'Hello'
  function say(name) {
    console.log(`${phrase}, ${name}`)
  }
  ```

![스크린샷 2021-05-27 오후 3 25 59](https://user-images.githubusercontent.com/71164350/119782127-c4f48400-bf06-11eb-93aa-22363229cd2f.png)

**(3) 내부와 외부 렉시컬 환경**

함수를 호출해 실행하면 새로운 렉시컬 환경이 만들어진다.   
이 렉시컬 환경엔 함수 호출 시 넘겨받은 매개변수와 함수의 지역변수가 저장된다.

  ```jsx
  let phrase = 'Hello'
  function say(name) {
    console.log(`${phrase}, ${name}`)
  }
  say('은지')
  ```

![스크린샷 2021-05-27 오후 3 33 40](https://user-images.githubusercontent.com/71164350/119782129-c58d1a80-bf06-11eb-87a3-5b11a0903130.png)

코드에서 변수를 접근할 땐, 먼저 내부 렉시컬 환경을 검색범위로 잡는다. 내부 렉시컬 환경에서 원하는 변수를 찾지 못하면, 검색 범위를 외부 렉시컬 환경으로 확장한다.  

위 과정은 검색 범위가 전역 렉시컬 환경으로 확장될 떄까지 반복된다.

**(4) 반환 함수**

```jsx
function makeCounter() {
  let count = 0

  return function () {
    return count++
  }
}

let counter = makeCounter()
counter() // 0
counter() // 1
counter() // 2
```

위 코드에서 `makeCounter()` 를 호출하면 호출할 때마다 새로운 렉시컬 환경 객체가 만들어진다.  
그리고 이 렉시컬 환경 객체엔 `makeCounter` 를 실행하는데 필요한 변수들이 저장된다.

![스크린샷 2021-05-27 오후 3 43 44](https://user-images.githubusercontent.com/71164350/119782130-c625b100-bf06-11eb-9566-6c68999fc16e.png)

위 `say` 함수와 다르게 `makeCounter` 에는 실행되는 도중에 중첩 함수가 만들어진다.

모든 함수는 함수가 생성된 곳의 렉시컬 환경을 기억하고,

함수는 `[[Environment]]` 라 불리는 숨김 프로퍼티를 갖는데, 이곳에 함수가 만들어진 곳의 렉시컬 환경에 대한 참조가 저장된다.

따라서 `counter.[[Environment]]` 엔 `{count: 0}` 이 있는 렉시컬 환경에 대한 참조가 저장된다. 호출 장소와 상관없이 함수가 자신이 태어난 곳을 기억할 수 있는건 바로 `[[Environment]]` 프로퍼티 덕분이고, **이 값은 함수가 생성될 때 딱 한번만 세팅이 되어, 이 값은 변하지 않는다.**

**변수값 갱신은 변수가 저장된 렉시컬 환경에서 이뤄져** counter()를 여러번 호출하면 변수가 바뀌는 이유가 바로 이 때문이다.

### 그래서, 클로저란?

'**클로저**'는 어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우, A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상을 말한다.

→ 자바스크립트의 함수는 숨김 프로퍼티인 `[[Environment]]` 를 이용해 자신이 어디서 만들어졌는지 기억하는데, 함수 내부의 코드는 `[[Environment]]` 를 이용해 외부 변수에 접근한다.

## 가비지 컬렉션

함수 호출이 끝나면 함수에 대응하는 렉시컬 환경이 메모리에서 제거된다. 이때 함수와 관련된 변수들은 모두 사라진다. 그런데 호출이 끝난 후에도 여전히 도달 가능한 중첩 함수가 있을 수 있다.

이때는 중첩함수의 `[[Environment]]` 프로퍼티에 외부 함수 렉시컬 환경에 대한 정보가 저장되어, 렉시컬 환경이 메모리에 유지되는 것이다.

```jsx
function f() {
  let value = 123
  return function () {
    alert(value)
  }
}
let g = f()
// g.[[Environment]]에 f() 호출시 만들어지는 렉시컬 환경 정보가 저장됨
g = null
```

여러번 중첩함수를 사용하고, 그 결과를 어딘가에 저장하는 경우 각 만들어진 렉시컬 환경 모두가 메모리에 유지되어 삭제되지 않는다.

해당 렉시컬 환경 객체를 참조하는 변수를 제거해줘야 메모리에서 제거된다.
