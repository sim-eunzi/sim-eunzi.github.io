---
title: 스코프의 작동방식, 렉시컬 스코프 (Lexical Scope)
date: '2021-05-13T20:31:37.121Z'
description: '변수의 유효범위, 스코프에 대해서 알아보자'
---

우리는 스코프를 엔진이 변수를 찾을 때 사용하는 '규칙의 집합' 이라고 정의했다.    
스코프는 두 가지 방식으로 작동하는데, 일방적으로 많이 사용하는 방식인 '**렉시컬 스코프**' 가 있고,  
일부 방식에서 쓰는 '동적 스코프'가 있다. 우리는 여기서 렉시컬 스코프에 대해 자세히 알아보자.

### 렉스타임

우리가 작성한 스크립트의 컴파일 과정에서 첫 단계는, **토크나이징(렉싱) 작업**으로 시작한다.  
렉싱 처리 과정에선 소스 코드 문자열을 분석하여, 상태 유지 파싱의 결과로 생성된 토큰에 큰 의미를 부여한다.
렉시컬 스코프는 이런 **렉싱 타임에 정의 되는 스코프**다.

**렉시컬 스코프는 코드를 짤 때 변수와 스코프 블록을 어디서 작성하는가에 기초해서 코드를 처리할 때 확정된다.**

### 검색

엔진은 스코프 버블의 구조와 상대적인 위치를 통해 어디를 검색해야 변수를 찾을 수 있는지를 안다.

스코프의 검색은 **가장 안쪽의 스코프 버블에서 시작**하고, **찾지 못하면 가장 가까운 스코프로 올라가서 찾고**,
목표와 일치하는 대상을 찾으면 즉시 검색을 중단한다.  
여러 중첩 스코프 층에 걸쳐 같은 변수 이름을 정의할 수도 있는데, 이를 **섀도잉** 이라 한다.

섀도잉과 상관없이 스코프 검색은 실행 시점에서 안쪽 스코프에서 시작하여 최초 목표와 일치하는 대상을 찾으면 멈추고,
그전까지는 바깥/위로 올라가면서 수행한다.  
렉시컬 스코프는 함수가 선언된 위치에 따라서 정의된다.

## 렉시컬 속이기

렉시컬 스코프는 개발자가 함수를 어디에 선언했는지에 따라 결정된다.  
그러면 런타임 때 렉시컬 스코프를 수정할 수 있을까?  
바로 **렉시컬 스코프를 속이는 방법**이다.  
하지만 이 방법 둘 다 성능이 떨어지기 때문에 코드 작성시에는 권장되지 않는 방법이다.

### eval()

`eval()` 함수는 문자열을 인자로 받아들여 실행 시점에 문자열의 내용을 코드의 일부분 처럼 처리한다.    
eval() 이 실행된 후 코드를 처리할 때, 엔진은 지난 코드가 **동적으로 해석되어** 렉시컬 스코프를 변경되었는지 알수가 없다.

```jsx
function foo(str, a) {
  eval(str)
  console.log(a, b)
}

var b = 2
foo('var b = 3', 1) // 1, 3
```

위의 실행 결과처럼 `var b = 3` 은 eval() 이 호출되는 시점에 원래 있던 코드인 것처럼 처리된다.  
새로운 변수 b를 선언하면서 이미 존재하는 foo() 의 렉시컬 스코프를 수정한다.

예외로 `strict mode` 에서는 eval() 에서 실행한 선언문이 현재 스코프를 수정하지는 않는다.

### with

`with` 키워드 또한 렉시컬 스코프를 속일 수 있는 자바스크립트의 다른 기능이다. 권장하지는 않지만..  
with 는 일반적으로 한 객체의 여러 속성을 참조할 때,   
객체 참조를 매번 반복하지 않기 위해서 사용하는 일종의 속기법이다.

```jsx
var obj = {
  a: 1,
  b: 2,
  c: 3,
}

obj.a = 2
obj.b = 3
obj.c = 4

with (obj) {
  a = 3
  b = 4
  c = 5
}

function foo(obj) {
  with (obj) {
    a = 2
  }
}

var o1 = { a: 3 }
var o2 = { b: 3 }

foo(o1)
console.log(o1.a)

foo(o2)
console.log(o2.a)
console.log(a)
```

함수 foo 는 객체 참조 obj 를 인자로 받아서 `with (obj) {}` 를 호출하고, with 블록 내부에서 변수 a 에 대한 평범한 렉시컬 참조를 수행한다.

with 문은 속성을 가진 객체를 받아 마치 하나의 독립된 렉시컬 스코프처럼 취급한다.

### 성능과 단점

eval() 과 with 가 엔진이 컴파일 단계에서 수행한 스코프 검색과 관련된 최적화 작업을 무산시킨다.  
엔진은 최악의 경우를 대비해 진행했던 최적화 결과과 무효화 됐다고 가정해야 하기 때문이다..
